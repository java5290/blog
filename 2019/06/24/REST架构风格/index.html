<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>REST架构风格 | stay clam, keep a good attitude, just now!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第1章 REST定义REST不是一种技术，也不是一个标准或协议，它使用既有标准：HTTP+URI+XML，来实现其要求的架构风格。因此与之对应的是像RPC这样的架构风格。 HTTP+URI+XML是REST的基本实现形式，但不是唯一的实现形式。学习和使用REST的关键是掌握这种思想，而不是具体的实现形式。">
<meta name="keywords" content="REST">
<meta property="og:type" content="article">
<meta property="og:title" content="REST架构风格">
<meta property="og:url" content="https://java5290.github.io/blog/2019/06/24/REST架构风格/index.html">
<meta property="og:site_name" content="stay clam, keep a good attitude, just now!">
<meta property="og:description" content="第1章 REST定义REST不是一种技术，也不是一个标准或协议，它使用既有标准：HTTP+URI+XML，来实现其要求的架构风格。因此与之对应的是像RPC这样的架构风格。 HTTP+URI+XML是REST的基本实现形式，但不是唯一的实现形式。学习和使用REST的关键是掌握这种思想，而不是具体的实现形式。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/java5290/image/raw/master/rest/uri.png">
<meta property="og:image" content="https://github.com/java5290/image/raw/master/rest/rest_request_work.png">
<meta property="og:updated_time" content="2019-07-04T03:30:08.071Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="REST架构风格">
<meta name="twitter:description" content="第1章 REST定义REST不是一种技术，也不是一个标准或协议，它使用既有标准：HTTP+URI+XML，来实现其要求的架构风格。因此与之对应的是像RPC这样的架构风格。 HTTP+URI+XML是REST的基本实现形式，但不是唯一的实现形式。学习和使用REST的关键是掌握这种思想，而不是具体的实现形式。">
<meta name="twitter:image" content="https://github.com/java5290/image/raw/master/rest/uri.png">
  
    <link rel="alternate" href="/blog/atom.xml" title="stay clam, keep a good attitude, just now!" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">stay clam, keep a good attitude, just now!</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">记录点点滴滴</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">首页</a>
        
          <a class="main-nav-link" href="/blog/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://java5290.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-REST架构风格" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/06/24/REST架构风格/" class="article-date">
  <time datetime="2019-06-24T08:40:54.000Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      REST架构风格
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第1章-REST定义"><a href="#第1章-REST定义" class="headerlink" title="第1章 REST定义"></a>第1章 REST定义</h2><p>REST不是一种技术，也不是一个标准或协议，它使用既有标准：HTTP+URI+XML，来实现其要求的架构风格。因此与之对应的是像RPC这样的架构风格。</p>
<p>HTTP+URI+XML是REST的基本实现形式，但不是唯一的实现形式。学习和使用REST的关键是掌握这种思想，而不是具体的实现形式。</p>
<a id="more"></a>
<h2 id="第2章-JAX-RS"><a href="#第2章-JAX-RS" class="headerlink" title="第2章 JAX-RS"></a>第2章 JAX-RS</h2><p>JAX-RS是Java领域的REST式的Web服务的标准规范。</p>
<h3 id="2-1-JAX-RS2标准"><a href="#2-1-JAX-RS2标准" class="headerlink" title="2.1 JAX-RS2标准"></a>2.1 JAX-RS2标准</h3><p>Java领域中的Web Service是指实现SOAP协议的JAX-WS。直到Java EE6通过JCP组织定义的JSR311，才将REST在Java领域标准化。<br>JSR311名为The Java API for RESTful Web Services即JAX-RS。<br>Java EE7包含了JSR 339，即升级到JAX-RS2.0。</p>
<h3 id="2-2-JAX-RS-2-0的目标"><a href="#2-2-JAX-RS-2-0的目标" class="headerlink" title="2.2 JAX-RS 2.0的目标"></a>2.2 JAX-RS 2.0的目标</h3><ol>
<li>基于POJO：JAX-RS 2.0的API提供一组注解（annotation）和相关的接口、类，并定义了POJO对象的声明周期和作用域。规定使用POJO来公布Web资源。</li>
<li>以HTTP为中心：JAX-RS 2.0采用HTTP协议，并提供清晰的HTTP和统一资源定位（URI）元素来映射相关的API类和注解。JAX-RS 2.0的API不但支持通用的HTTP使用模式，还对WebDAV和Atom等扩展协议提供灵活的支持。</li>
<li>格式独立性：JAX-RS 2.0对传输数据（HTTP Entity）的类型/格式的支持非常宽泛，允许在标准风格之上使用额外的数据类型。</li>
<li>容器独立性：JAX-RS 2.0的应用可以部署在各种Servlet容器中，比如Tomcat/Jetty，也可以部署在支持JAX-WS的容器中，比如GlassFish。</li>
<li>内置于Java EE：JAX-RS 2.0是Java EE规范的一部分，它定义了在一个Java EE容器内的Web资源类的内部，如何使用Java EE的功能和组件。<h3 id="2-3-JAX-RS典型实现"><a href="#2-3-JAX-RS典型实现" class="headerlink" title="2.3 JAX-RS典型实现"></a>2.3 JAX-RS典型实现</h3><h4 id="2-3-1-Apache-CXF"><a href="#2-3-1-Apache-CXF" class="headerlink" title="2.3.1 Apache CXF"></a>2.3.1 Apache CXF</h4>CXF是JAX-WS的著名实现，同时实现了JAX-RS。<h4 id="2-3-2-Spring-MVC"><a href="#2-3-2-Spring-MVC" class="headerlink" title="2.3.2 Spring MVC"></a>2.3.2 Spring MVC</h4>JAX-RS是Java领域实现REST式Web服务的标准规范。但是Java领域支持REST式Web服务开发的工具未必遵循JAX-RS规范。其中Spring MVC就是一个支持REST开发的非JAX-RS规范的实现。<h2 id="第3章-REST-API设计"><a href="#第3章-REST-API设计" class="headerlink" title="第3章 REST API设计"></a>第3章 REST API设计</h2>设计和开发REST式的Web服务除了要掌握JAX-RS 2.0标准，还要对统一接口、资源定位以及请求处理过程中REST风格的传输数据的格式、响应信息等有良好的认知。<h3 id="3-1-REST统一接口"><a href="#3-1-REST统一接口" class="headerlink" title="3.1 REST统一接口"></a>3.1 REST统一接口</h3>REST式的Web服务和RPC式的Web服务在接口定义上的区别是，REST使用HTTP的通用方法作为统一接口的标准词汇。REST式的Web服务所提供的方法信息都在HTTP方法里，而RPC式的Web服务所提供的方法信息在SOAP/HTTP信封里（其封装的格式通常是HTTP或者是SOAP），每一个RPC式的Web服务都会公布一套符合自己商业逻辑的方法词汇。</li>
</ol>
<p>每一种HTTP请求方法都可以从安全性和幂等性两方面考虑：</p>
<ul>
<li><p>安全性：代表安全的REST接口，是指外系统对该接口的访问，不会使服务器端资源的状态发生改变；</p>
</li>
<li><p>幂等性：指外系统对同一REST接口的多次访问，得到的资源状态是相同的。</p>
<h4 id="3-1-1-GET方法"><a href="#3-1-1-GET方法" class="headerlink" title="3.1.1 GET方法"></a>3.1.1 GET方法</h4><p>虽然GET方法的特性是幂等和安全的，但这不意味着任何一个定义为处理GET请求的方法都是幂等和安全的，即设计不良的API有可能违背GET的特性，将一个不该是GET的方法定义为之。</p>
<h4 id="3-1-2-PUT方法"><a href="#3-1-2-PUT方法" class="headerlink" title="3.1.2 PUT方法"></a>3.1.2 PUT方法</h4><p>PUT方法是一种写操作的HTTP请求。REST使用HTTP的PUT方法更新或添加资源。</p>
</li>
</ul>
<p>PUT方法是幂等的，不安全的。</p>
<ul>
<li><p>更新资源：使用PUT没问题。</p>
</li>
<li><p>添加资源：通常使用POST方法，唯一场景，客户端新添加资源时，主键不变，这样的添加资源请求可以使用PUT方法。</p>
<h4 id="3-1-3-DELETE方法"><a href="#3-1-3-DELETE方法" class="headerlink" title="3.1.3 DELETE方法"></a>3.1.3 DELETE方法</h4><p>DELETE方法是幂等的，即多次删除同一份数据，在服务器端产生的改变是相同的。</p>
<h4 id="3-1-4-POST方法"><a href="#3-1-4-POST方法" class="headerlink" title="3.1.4 POST方法"></a>3.1.4 POST方法</h4><p>POST方法是一种写操作的HTTP请求。RPC的所有写操作均使用POST方法，而REST只使用HTTP的POST方法添加资源。</p>
</li>
</ul>
<p>POST方法是既不幂等也不安全。</p>
<h3 id="3-2-REST资源定位"><a href="#3-2-REST资源定位" class="headerlink" title="3.2 REST资源定位"></a>3.2 REST资源定位</h3><p>示例：<a href="http://localhost:8080/demo-rest/rbac/user/list?id=1" target="_blank" rel="noopener">http://localhost:8080/demo-rest/rbac/user/list?id=1</a></p>
<ul>
<li>ContextPath: demo-rest，上下文名称</li>
<li>ServletPath: rbac，Servlet的名称</li>
<li>PathInfo: user/list，资源路径信息</li>
</ul>
<p>资源地址是否可以唯一定位一个资源？</p>
<p>资源地址相同，但HTTP方法不同的两个方法是两个不同的REST接口。HTTP方法和资源地址结合在一起才可以完成对资源的定位。</p>
<p>资源地址设计：</p>
<p><img src="https://github.com/java5290/image/raw/master/rest/uri.png" alt="资源地址设计"></p>
<h3 id="3-3-REST传输格式"><a href="#3-3-REST传输格式" class="headerlink" title="3.3 REST传输格式"></a>3.3 REST传输格式</h3><ul>
<li><p>基本类型：byte、short、int、long、float、double、char、boolean；</p>
</li>
<li><p>文件类型：方便客户端直接传递File类实例给服务器端；文件类型的请求，默认使用媒体类型是Content-Type:text/html；</p>
</li>
<li><p>InputStream类型： 字节流</p>
</li>
<li><p>Reader类型：字符流</p>
</li>
<li><p>XML类型：支持JAXP和JAXB</p>
</li>
<li><p>JSON类型：已经成为AJAX技术中数据传输的实际标准</p>
<h3 id="3-4-REST响应处理"><a href="#3-4-REST响应处理" class="headerlink" title="3.4 REST响应处理"></a>3.4 REST响应处理</h3><p>REST的响应处理结果应包括响应头中HTTP状态码，响应实体中媒体参数类型和返回值类型，以及异常情况处理。JAX-RS 2.0支持4种返回值类型的响应：</p>
</li>
<li><p>无返回值</p>
</li>
<li><p>返回Response类实例</p>
</li>
<li><p>返回GenericEntity类实例</p>
</li>
<li><p>返回自定义类实例</p>
<h4 id="3-4-1-void"><a href="#3-4-1-void" class="headerlink" title="3.4.1 void"></a>3.4.1 void</h4><p>在返回值类型是void的响应中，其响应实体为空，HTTP状态码为204。</p>
<h4 id="3-4-2-Response"><a href="#3-4-2-Response" class="headerlink" title="3.4.2 Response"></a>3.4.2 Response</h4><p>在返回值类型位Response的响应中，响应实体为Response类的entity()方法定义的实体类实例。如果该内容为空，则HTTP状态码为204，否则HTTP状态码为200 OK。</p>
<h4 id="3-4-3-GenericEntity"><a href="#3-4-3-GenericEntity" class="headerlink" title="3.4.3 GenericEntity"></a>3.4.3 GenericEntity</h4><p>通用实体类型作为返回值的情况并不常用。其形式是构造一个统一的实体实例并将其返回，实体实例作为第一个参数，该实体类型作为第二个参数。</p>
<h4 id="3-4-4-自定义类型"><a href="#3-4-4-自定义类型" class="headerlink" title="3.4.4 自定义类型"></a>3.4.4 自定义类型</h4><p>常用的是返回自定义的POJO类型。</p>
<h4 id="3-4-5-处理异常"><a href="#3-4-5-处理异常" class="headerlink" title="3.4.5 处理异常"></a>3.4.5 处理异常</h4><p>实现REST的资源方法时应使其具有良好的异常处理能力，这包括异常的定义和错误状态码的正确返回。</p>
</li>
</ul>
<p>常用状态码：</p>
<ul>
<li>200 OK 服务器正常响应</li>
<li>201 Created 创建新实体，响应头Location指定访问该实体的URL</li>
<li>202 Accepted 服务器接收请求，处理尚未完成。可用于异步处理机制</li>
<li>204 Not Content 服务器正常响应，但响应实体为空</li>
<li>301 Moved Permancntly 请求资源的地址发生永久变动，响应头Location指定新的URL</li>
<li>302 Found 请求资源的地址发生临时变动</li>
<li>304 Not Modified 客户端缓存资源依然有效</li>
<li>400 Bad Request 请求信息出现语法错误</li>
<li>401 Unauthorized 请求资源无法授权给未验证用户</li>
<li>403 Forbidden 请求资源未授权当前用户</li>
<li>404 Not Found 请求资源不存在</li>
<li>405 Method Not Allowed 请求方法不匹配</li>
<li>406 Not Acceptable 请求资源的媒体类型不匹配</li>
<li>500 Internal Server Error 服务器内部错误，意外终止响应</li>
<li>501 Not Implemented  服务器不支持当前请求</li>
</ul>
<p>基本异常类：</p>
<p>JAX-RS 2.0规定的REST式的Web服务的基本异常类型为运行时异常WebApplicationException类。</p>
<h3 id="3-5-REST内容协商"><a href="#3-5-REST内容协商" class="headerlink" title="3.5 REST内容协商"></a>3.5 REST内容协商</h3><p>内容协商不只是数据格式协商，还包括语言、编码、字符集等信息。Accept用于数据类型协商，Accept-language用于语言协商，Accept-Charset用于字符集协商，Accept-Encoding用于压缩算法协商。</p>
<p>JAX-RS 2.0对内容协商的支持，是通过@Produces实现的，对于其他协商，没有从架构上提供支持，可以通过编码从请求头中获取信息并处理。</p>
<h4 id="3-5-1-Produces注解"><a href="#3-5-1-Produces注解" class="headerlink" title="3.5.1 @Produces注解"></a>3.5.1 @Produces注解</h4><p>用于定义方法的响应实体的数据类型。可以定义一个或多个，同时可以为每种类型定义质量因素，质量因素是取值范围从0~1的小数值。</p>
<h4 id="3-5-2-Consumes注解"><a href="#3-5-2-Consumes注解" class="headerlink" title="3.5.2 @Consumes注解"></a>3.5.2 @Consumes注解</h4><p>用于定义方法的请求实体的数据类型。@Consumes的数据类型的定义只用于JAX-RS 2.0匹配请求处理的方法，不做内容协商使用。如果匹配不到，那么服务器会返回HTTP状态码415（Unsupported Media Type）。</p>
<h2 id="第4章-REST请求处理"><a href="#第4章-REST请求处理" class="headerlink" title="第4章 REST请求处理"></a>第4章 REST请求处理</h2><p>REST和AOP<br>AOP对增强REST式的Web服务的功能性、安全性和可扩展性等方面都具有深远意义，因此完整的REST风格的框架都从容器级别支持AOP式的开发。</p>
<p>Jersey提供的REST过滤器和拦截器为开发者提供了很贴心的切面扩展点，在Jersey中，只要实现相应扩展点的接口，即可实现REST请求流程中特定事件点的拦截、扩展。</p>
<p>典型的应用包括请求和响应的过滤和读写拦截。</p>
<h3 id="4-1-Providers"><a href="#4-1-Providers" class="headerlink" title="4.1 Providers"></a>4.1 Providers</h3><p>javax.ws.rs.ext.Providers是JAX-RS 2.0定义的一种辅助接口，其实现类用于辅助REST框架完成过滤和读写拦截等功能。使用注解@Provider来标注这些实现类，可以被JAX-RS 2.0的运行时自动探测、加载。</p>
<h3 id="4-2-REST请求流程"><a href="#4-2-REST请求流程" class="headerlink" title="4.2 REST请求流程"></a>4.2 REST请求流程</h3><p><img src="https://github.com/java5290/image/raw/master/rest/rest_request_work.png" alt="Jersey的REST请求处理流程"></p>
<h3 id="4-3-REST过滤器"><a href="#4-3-REST过滤器" class="headerlink" title="4.3 REST过滤器"></a>4.3 REST过滤器</h3><p>JAX-RS 2.0定义的4种过滤器扩展点接口，供开发者实现业务逻辑，按照请求处理流程的先后顺序为：</p>
<ol>
<li>客户端请求过滤器 ClientRequestFilter</li>
<li>服务器请求过滤器 ContainerRequestFilter</li>
<li>服务器响应过滤器 ContainerResponseFilter</li>
<li>客户端响应过滤器 ClientResponseFilter</li>
</ol>
<h3 id="4-4-REST拦截器"><a href="#4-4-REST拦截器" class="headerlink" title="4.4 REST拦截器"></a>4.4 REST拦截器</h3><p>拦截器和过滤器的相同之处在于都是一种在请求-响应模型中用作切面处理的Provider。两者的不同除了功能上的差异（一个用于过滤消息，另一个用于拦截处理）之外，形式上也不同。</p>
<p>拦截器通常读写成对，而且没有服务器端和客户端的区分。</p>
<h3 id="4-5-绑定机制"><a href="#4-5-绑定机制" class="headerlink" title="4.5 绑定机制"></a>4.5 绑定机制</h3><p>默认情况下，过滤器和拦截器都是全局绑定的，即下面两种方式：</p>
<ul>
<li><p>通过手动注册到Application或者Configuration。</p>
</li>
<li><p>注解为@Provider，被自动探测。</p>
</li>
</ul>
<p>其他绑定机制：</p>
<ol>
<li><p>名称绑定：名称绑定注解、绑定Provider、绑定方法</p>
</li>
<li><p>动态绑定：通过编码方式，实现接口DynamicFeature</p>
<h3 id="4-6-优先级"><a href="#4-6-优先级" class="headerlink" title="4.6 优先级"></a>4.6 优先级</h3><p>对于同一个扩展点的多个Provider的执行先后顺序是靠优先级排序的。</p>
</li>
</ol>
<p>优先级的定义使用注解@Priority，优先级的值是一个整型值。对于请求拦截器采用升序策略，对于响应采用降序策略。</p>
<h2 id="第5章-REST客户端"><a href="#第5章-REST客户端" class="headerlink" title="第5章 REST客户端"></a>第5章 REST客户端</h2><p>客户端API通过HTTP请求Web资源，其设计宗旨是使客户端API符合统一接口和REST架构风格，同时客户端API应该易于使用，而且服务器端在概念和扩展点上保持一致。</p>
<p>JAX-RS 2.0标准化了Client API（客户端API）。Jersey 2.X的客户端包jersey-client实现了JAX-RS 2.0的客户端API，并对其进行了可插拨的扩展。</p>
<h3 id="5-1-客户端接口"><a href="#5-1-客户端接口" class="headerlink" title="5.1 客户端接口"></a>5.1 客户端接口</h3><p>客户端主要包括三个接口：</p>
<ul>
<li><p>javax.ws.rs.client.Client 是REST客户端的基本接口，用于和REST服务器通信，不推荐在应用中产生大量的Client实例。</p>
</li>
<li><p>javax.ws.rs.client.WebTarget 为REST客户端实现资源定位的接口。</p>
</li>
<li><p>javax.ws.rs.client.Invocation 是在完成资源定位配置后，向REST服务端发起请求的接口。</p>
<h3 id="5-2-资源释放"><a href="#5-2-资源释放" class="headerlink" title="5.2 资源释放"></a>5.2 资源释放</h3><p>JAX-RS 2.0不希望开发者编码实现对客户端实例的资源管理，Response实例的readEntity()在返回响应实体的同时，即完成了对客户端资源的释放。因此，开发者无须担心连接、释放等资源管理细节。</p>
</li>
</ul>
<h3 id="5-3-连接器"><a href="#5-3-连接器" class="headerlink" title="5.3 连接器"></a>5.3 连接器</h3><p>Connector接口是REST客户端底层连接器接口，Jersey为Connector接口提供了4个实现。</p>
<ul>
<li>HttpUrlConnector 默认连接器</li>
<li>ApacheConnector 基于Apache HTTP Client的连接器实现，相比默认的连接器功能更完整、强大</li>
<li>GrizzlyConnector 是Grizzly提供的连接器实现，其内部使用异步处理客户端AsyncHttpClient类作为底层的连接</li>
<li>InMemoryConnector <h3 id="5-4-封装Client"><a href="#5-4-封装Client" class="headerlink" title="5.4 封装Client"></a>5.4 封装Client</h3>REST式的Web服务会按照模块分别提供独立的Web服务，而模块之间的调用通过Web服务的REST API来实现。因此，每个模块对其他模块的调用即是客户端请求，不必在每次请求时重复编写构造客户端实例的代码。为此，抽象出Client到公共模块是非常有必要的。<h2 id="第6章-REST安全"><a href="#第6章-REST安全" class="headerlink" title="第6章 REST安全"></a>第6章 REST安全</h2></li>
<li>Authentication 认证，识别访问者身份的过程</li>
<li>Authorization 授权，授予权限的过程</li>
<li>Accounting 账户<h3 id="6-1-身份认证"><a href="#6-1-身份认证" class="headerlink" title="6.1 身份认证"></a>6.1 身份认证</h3>HTTP认证规范定义了两种HTTP身份认证方式：HTTP Basic（基本认证）和HTTP Digest（摘要认证）。HTTP认证是一种无状态的认证方式，身份信息随着浏览器的关闭而消失。Java平台包含了HTTP的两种身份认证，此外还定义了表单认证和证书认证。</li>
</ul>
<p>基本认证、摘要认证和表单认证都是基于“用户-密码”的认证机制，而证书认证是基于证书的认证机制。</p>
<p>基本认证和表单认证的请求过程需要提交用户的密码信息，而且对服务器的合法性缺乏判断依据；摘要认证和证书认证的请求过程将对服务器的合法性进行验证而且不直接提交用户的密码。</p>
<h4 id="6-1-1-基本认证"><a href="#6-1-1-基本认证" class="headerlink" title="6.1.1 基本认证"></a>6.1.1 基本认证</h4><p>HTTP基本认证是指通过Web浏览器或其它客户端在发送请求时，提供用户名和密码作为身份凭证的一种登录验证方式。在发送请求之前，用户名和密码字符串通过一个冒号合并，合并后的字符串经过Base64算法进行编码。Base64编码的目的并不是实现安全与隐私，而是为了将用户名和密码中的与HTTP不兼容的字符转换为兼容的字符集。</p>
<h4 id="6-1-2-摘要认证"><a href="#6-1-2-摘要认证" class="headerlink" title="6.1.2 摘要认证"></a>6.1.2 摘要认证</h4><p>摘要认证以服务器生成的随机数来维护安全性。后续引入了一系列安全增强的选项，这些增强项有效地防止了通信过程中的明文攻击。</p>
<h4 id="6-1-3-表单认证"><a href="#6-1-3-表单认证" class="headerlink" title="6.1.3 表单认证"></a>6.1.3 表单认证</h4><p>表单认证是基于HTTP，使用HTML的Form标签提交表单的认证形式。最常见的登录页面就是表单认证方式。</p>
<h4 id="6-1-4-证书认证"><a href="#6-1-4-证书认证" class="headerlink" title="6.1.4 证书认证"></a>6.1.4 证书认证</h4><p>证书认证是通过数字证书认证身份的方式。这一方式从技术角度可以拆分为证书管理和通信协议两个环节。证书是静态的文件，为基于SSL/TLS协议的通信过程所用。</p>
<p>非对称加密：公钥加密、私钥解密。</p>
<h3 id="6-2-资源授权"><a href="#6-2-资源授权" class="headerlink" title="6.2 资源授权"></a>6.2 资源授权</h3><h4 id="6-2-1-容器管理权限"><a href="#6-2-1-容器管理权限" class="headerlink" title="6.2.1 容器管理权限"></a>6.2.1 容器管理权限</h4><p>容器管理权限提供无编码的、可配置的全局的管理方式，零编码、方便统一管理。</p>
<p>容器管理权限指容器通过启动时从其配置文佳中加载角色-权限信息，在运行时对用户身份进行认证，并对其角色的资源访问权限进行管控的方式。</p>
<h4 id="6-2-2-应用管理权限"><a href="#6-2-2-应用管理权限" class="headerlink" title="6.2.2 应用管理权限"></a>6.2.2 应用管理权限</h4><p>应用管理权限提供细粒度的权限管理，通过编码使具体业务额权限分配更灵活。</p>
<p>相对于容器管理权限，应用管理权限是指容器中的每个应用各自通过编码和注解完成对资源路径访问的权限管理。</p>
<h3 id="6-3-认证与授权的实现"><a href="#6-3-认证与授权的实现" class="headerlink" title="6.3 认证与授权的实现"></a>6.3 认证与授权的实现</h3><p>实际中常用实现：</p>
<ul>
<li><p>shiro</p>
</li>
<li><p>JWT+RBAC</p>
<h3 id="6-4-其他安全考虑"><a href="#6-4-其他安全考虑" class="headerlink" title="6.4 其他安全考虑"></a>6.4 其他安全考虑</h3></li>
<li><p>AJAX跨域安全：XSS跨站脚本攻击和CSRF跨站点请求伪造</p>
</li>
<li><p>OAuth和OAuth2：</p>
<h2 id="第7章-REST测试"><a href="#第7章-REST测试" class="headerlink" title="第7章 REST测试"></a>第7章 REST测试</h2><p>自动化测试是软件质量保证的必要手段。</p>
</li>
</ul>
<p>项目源代码的代码覆盖率即指测试代码中对源代码的公有方法的覆盖情况，是CI(持续集成)和CD(持续交付)中的重要指标之一。</p>
<p>使用JUnit结合Jersey的测试框架，能够轻松地实现单元测试、CI测试和系统测试。</p>
<h2 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h2><p>《Java RESTful Web Service实战》 韩陆 著</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://java5290.github.io/blog/2019/06/24/REST架构风格/" data-id="cjxo1z5r3000e00dkxfwuei4c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/REST/">REST</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2019/07/02/人脸检测之dlib/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          人脸检测之dlib
        
      </div>
    </a>
  
  
    <a href="/blog/2019/06/20/无状态应用之JWT的token实战/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">无状态应用之JWT的token实战</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/REST/">REST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/oracle/">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/分布式系统/">分布式系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/自我调节/">自我调节</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/REST/" style="font-size: 10px;">REST</a> <a href="/blog/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/blog/tags/分布式系统/" style="font-size: 10px;">分布式系统</a> <a href="/blog/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/blog/tags/自我调节/" style="font-size: 10px;">自我调节</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019/07/02/人脸检测之dlib/">人脸检测之dlib</a>
          </li>
        
          <li>
            <a href="/blog/2019/06/24/REST架构风格/">REST架构风格</a>
          </li>
        
          <li>
            <a href="/blog/2019/06/20/无状态应用之JWT的token实战/">无状态应用之JWT的token实战</a>
          </li>
        
          <li>
            <a href="/blog/2019/06/13/ORA-00600-内部错误代码，参数：-25027-，-44-，-0/">ORA-00600: 内部错误代码，参数：[25027]，[44]，[0]</a>
          </li>
        
          <li>
            <a href="/blog/2019/06/13/保持冷静，保持良好的心态，就现在/">保持冷静，保持良好的心态，就现在</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 laoli5290<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!-- 不蒜子统计 -->
        <span id="busuanzi_container_site_pv">
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
        </span>      
      
    </div>
  </div>  
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">首页</a>
  
    <a href="/blog/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>